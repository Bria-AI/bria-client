import asyncio
import time
from collections.abc import Awaitable

from httpx import Response

from bria_engine_api.constants import BriaEngineAPIRoutes
from bria_engine_api.enable_sync_decorator import enable_run_synchronously
from bria_engine_api.engine_client import BriaEngineClient
from bria_engine_api.schemas.status_api import StatusAPIResponse, StatusAPIState


class StatusAPI:
    def __init__(self, engine_requests_client: BriaEngineClient):
        self.engine_api = engine_requests_client

    @enable_run_synchronously
    async def wait_for_status_request(self, request_id: str, timeout: int = 120, interval: int = 2) -> Awaitable[StatusAPIResponse] | StatusAPIResponse:
        """
        Polling the status from the status API until the request completes or fails

        Args:
            `request_id: str` - The request ID to wait for (generated by the API)
            `timeout: int` - The timeout in seconds
            `interval: int` - The interval in seconds

        Returns:
            `StatusAPIResponse` - The status response body (error or result properties will be populated)

        Raises:
            `EngineAPIException` - When the status request fails
            `TimeoutError` - If the timeout is reached while waiting for the status request
        """
        start_time = time.time()
        while time.time() - start_time < timeout:
            res: Response = await self.engine_api.get(f"{BriaEngineAPIRoutes.V2_STATUS}/{request_id}")
            data: dict = res.json()

            status_response: StatusAPIResponse = StatusAPIResponse(**data)
            if status_response.status != StatusAPIState.IN_PROGRESS.value:
                return status_response

            await asyncio.sleep(interval)

        raise TimeoutError("Timeout reached while waiting for status request")
