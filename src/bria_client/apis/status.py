import asyncio
import time

from httpx import Response

from bria_client.constants import BriaEngineAPIRoutes
from bria_client.decorators.enable_sync_decorator import enable_run_synchronously
from bria_client.engine_client import BriaEngineClient
from bria_client.schemas.status_api import StatusAPIResponse, StatusAPIState


class StatusAPI:
    def __init__(self, engine_requests_client: BriaEngineClient):
        self.engine_api = engine_requests_client

    @enable_run_synchronously
    async def wait_for_status_request(self, request_id: str, timeout: int | None = 120, interval: int | None = 2) -> StatusAPIResponse:
        """
        Polling the status from the status API until the request completes or fails

        Args:
            `request_id: str` - The request ID to wait for (generated by the API)
            `timeout: int` - The timeout in seconds
            `interval: int` - The interval in seconds

        Returns:
            `StatusAPIResponse` - The status response body (error or result properties will be populated)

        Raises:
            `EngineAPIException` - When the status request fails
            `TimeoutError` - If the timeout is reached while waiting for the status request
        """
        # Handle None values explicitly passed from decorator (which overrides defaults)
        timeout = timeout if timeout is not None else 120
        interval = interval if interval is not None else 2
        start_time = time.time()
        while time.time() - start_time < timeout:
            res: Response = await self.engine_api.get(f"{BriaEngineAPIRoutes.V2_STATUS}/{request_id}")
            data: dict = res.json()

            status_response: StatusAPIResponse = StatusAPIResponse(**data, http_request_status=res.status_code)
            if status_response.status != StatusAPIState.IN_PROGRESS.value:
                return status_response

            await asyncio.sleep(interval)

        raise TimeoutError("Timeout reached while waiting for status request")
