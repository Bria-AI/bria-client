import asyncio
import time

from httpx import Response

from bria_client.constants import BriaEngineAPIRoutes
from bria_client.decorators.enable_sync_decorator import enable_run_synchronously
from bria_client.engines.base import ApiEngine
from bria_client.responses.status_response import StatusResponse
from bria_client.schemas.status_api import StatusAPIResponse, StatusAPIState


class StatusAPI:
    def __init__(self, api_engine: ApiEngine):
        self.api_engine = api_engine

    def get_status(self, request_id: str):
        response = self.api_engine.get(f"/{BriaEngineAPIRoutes.V2_STATUS}/{request_id}", response_obj=StatusResponse)
        return response

    @enable_run_synchronously
    async def wait_for_status_request(self, request_id: str, timeout: int = 120, interval: int = 2) -> StatusAPIResponse:
        """
        Polling the status from the status API until the request completes or fails

        Args:
            `request_id: str` - The request ID to wait for (generated by the API)
            `timeout: int` - The timeout in seconds
            `interval: int` - The interval in seconds

        Returns:
            `StatusAPIResponse` - The status response body (error or result properties will be populated)

        Raises:
            `EngineAPIException` - When the status request fails
            `TimeoutError` - If the timeout is reached while waiting for the status request
        """
        start_time = time.time()
        while time.time() - start_time < timeout:
            res: Response = await self.api_engine.get(f"{BriaEngineAPIRoutes.V2_STATUS}/{request_id}")
            data: dict = res.json()

            status_response: StatusAPIResponse = StatusAPIResponse(**data, http_request_status=res.status_code)
            if status_response.status != StatusAPIState.IN_PROGRESS.value:
                return status_response

            await asyncio.sleep(interval)

        raise TimeoutError("Timeout reached while waiting for status request")
